<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Fight Graph 3D Prototype</title>
    <style>
      :root {
        color-scheme: light dark;
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      }

      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        background: radial-gradient(circle at top, #0f172a, #020617);
        color: #e2e8f0;
      }

      header {
        padding: 1.25rem 1.5rem 0.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        background: linear-gradient(180deg, rgba(15, 23, 42, 0.95), rgba(15, 23, 42, 0.4));
        backdrop-filter: blur(18px);
        border-bottom: 1px solid rgba(148, 163, 184, 0.18);
        box-shadow: 0 18px 34px rgba(15, 23, 42, 0.45);
        z-index: 2;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.4rem, 2vw + 1rem, 2.1rem);
        letter-spacing: 0.04em;
      }

      p {
        margin: 0;
        max-width: 64rem;
        color: rgba(226, 232, 240, 0.82);
        line-height: 1.5;
      }

      #status-banner {
        min-height: 2.5rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1.5rem;
        border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        background: rgba(15, 23, 42, 0.72);
        backdrop-filter: blur(12px);
        font-size: 0.95rem;
      }

      #status-indicator {
        width: 0.75rem;
        height: 0.75rem;
        border-radius: 999px;
        box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.18);
        background: #38bdf8;
        transition: background 0.2s ease;
      }

      #scene-container {
        flex: 1;
        position: relative;
      }

      #tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(148, 163, 184, 0.35);
        border-radius: 0.75rem;
        padding: 0.75rem 1rem;
        min-width: 12rem;
        font-size: 0.9rem;
        line-height: 1.35;
        box-shadow: 0 18px 28px rgba(15, 23, 42, 0.45);
        transform: translate(-50%, -140%);
        display: none;
        z-index: 10;
      }

      #controls {
        position: absolute;
        bottom: 1.5rem;
        left: 1.5rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        padding: 1rem 1.25rem;
        background: rgba(2, 6, 23, 0.7);
        border-radius: 0.75rem;
        border: 1px solid rgba(148, 163, 184, 0.16);
        box-shadow: 0 12px 32px rgba(15, 23, 42, 0.6);
        font-size: 0.85rem;
        max-width: 20rem;
      }

      code {
        font-family: "Fira Code", "JetBrains Mono", "SFMono-Regular", monospace;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        background: rgba(56, 189, 248, 0.15);
        color: #bae6fd;
        padding: 0.15rem 0.55rem;
        border-radius: 999px;
        font-size: 0.75rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
      }

      a {
        color: #38bdf8;
      }
    </style>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
      }
    }
    </script>
  </head>
  <body>
    <header>
      <div class="badge">Experimental</div>
      <h1>Fight Graph — Three.js Exploratory Prototype</h1>
      <p>
        This standalone page demonstrates how the fight web can be rendered in a fully interactive
        three-dimensional scene using <strong>Three.js</strong> for visualization and
        <strong>d3-force-3d</strong> for layout. Use URL query parameters (for example
        <code>?apiBaseUrl=http://localhost:8000</code>) or inject <code>window.__API_BASE_URL__</code>
        at runtime to target a custom backend without rebuilding the asset.
      </p>
    </header>
    <section id="status-banner" role="status">
      <span id="status-indicator" aria-hidden="true"></span>
      <span id="status-message">Initializing…</span>
    </section>
    <main id="scene-container" aria-live="polite">
      <div id="tooltip" role="presentation"></div>
      <aside id="controls">
        <strong>Interaction tips</strong>
        <ul>
          <li>Drag to orbit, scroll to zoom, or right-click + drag to pan the camera.</li>
          <li>Hover any fighter sphere to inspect metadata.</li>
          <li>Click a fighter to “lock” the tooltip in place; click empty space to release.</li>
          <li>Use the query parameter <code>iterations</code> to experiment with layout passes.</li>
        </ul>
        <p>
          API errors, fetch latency, and layout metrics are surfaced directly in the status banner to
          make debugging integrations easier.
        </p>
      </aside>
    </main>

    <script type="module">
      // Import modern Three.js module build plus orbit controls directly from the jsDelivr CDN.
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js";
      import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/controls/OrbitControls.js";
      import {
        forceSimulation,
        forceManyBody,
        forceLink,
        forceCenter,
      } from "https://cdn.skypack.dev/d3-force-3d@3.0.5";

      /**
       * @typedef {Object} FightGraphNode
       * @property {string} fighter_id - Stable unique identifier for the fighter.
       * @property {string} name - Fighter display name.
       * @property {string | null | undefined} [division] - Weight class label if known.
       * @property {string | null | undefined} [record] - Human readable win/loss record.
       * @property {string | null | undefined} [image_url] - Optional portrait URL.
       * @property {number} total_fights - Aggregated bout count inside the graph.
       * @property {string | null | undefined} [latest_event_date] - ISO timestamp of the most recent fight.
       */

      /**
       * @typedef {Object} FightGraphLink
       * @property {string} source - Fighter identifier for the graph edge source.
       * @property {string} target - Fighter identifier for the graph edge target.
       * @property {number} fights - Number of bouts connecting the pair.
       * @property {Object<string, Record<string, number | undefined>>} result_breakdown - Outcome tally per promotion.
       * @property {string | null | undefined} [first_event_name]
       * @property {string | null | undefined} [first_event_date]
       * @property {string | null | undefined} [last_event_name]
       * @property {string | null | undefined} [last_event_date]
       */

      /**
       * @typedef {Object} FightGraphResponse
       * @property {FightGraphNode[]} nodes
       * @property {FightGraphLink[]} links
       * @property {Record<string, unknown>} metadata
       */

      /** Palette borrowed from the production graph layout module. */
      const COLOR_PALETTE = [
        "#2563eb",
        "#f97316",
        "#10b981",
        "#a855f7",
        "#ec4899",
        "#facc15",
        "#14b8a6",
        "#f43f5e",
        "#0ea5e9",
        "#22c55e",
      ];

      /** Default fallback color for divisions lacking explicit mapping. */
      const DEFAULT_DIVISION_COLOR = "#64748b";

      const DEFAULT_API_BASE_URL = "http://localhost:8000";

      const statusIndicator = /** @type {HTMLSpanElement} */ (
        document.getElementById("status-indicator")
      );
      const statusMessage = /** @type {HTMLSpanElement} */ (
        document.getElementById("status-message")
      );
      const tooltip = /** @type {HTMLDivElement} */ (document.getElementById("tooltip"));
      const sceneContainer = /** @type {HTMLDivElement} */ (
        document.getElementById("scene-container")
      );

      /**
       * Updates the banner with contextual diagnostics. Colors follow a traffic light pattern.
       * @param {"idle" | "loading" | "error" | "success"} state - Visual state for the indicator.
       * @param {string} message - User-facing explanation for the current lifecycle stage.
       */
      function updateStatus(state, message) {
        statusMessage.textContent = message;
        const palette = {
          idle: "#38bdf8",
          loading: "#facc15",
          success: "#34d399",
          error: "#f97316",
        };
        statusIndicator.style.background = palette[state] ?? palette.idle;
      }

      /**
       * Normalizes candidate base URLs to absolute form (mimicking resolveApiBaseUrl).
       * Invalid inputs fall back to the provided default.
       * @param {string | undefined | null} raw
       * @param {string} fallback
       */
      function resolveApiBaseUrl(raw, fallback) {
        const trimmed = raw?.trim();
        if (!trimmed) {
          return fallback;
        }
        const candidates = [trimmed];
        if (!/^[a-zA-Z][\w+.-]*:/.test(trimmed)) {
          const scheme = /^(localhost|127\.|0\.0\.0\.0|\[::1\])/.test(trimmed)
            ? "http://"
            : "https://";
          candidates.push(`${scheme}${trimmed}`);
        }
        for (const candidate of candidates) {
          try {
            const normalized = new URL(candidate);
            if (normalized.origin === "null") {
              continue;
            }
            const path = normalized.pathname === "/" ? "" : normalized.pathname.replace(/\/$/, "");
            return `${normalized.origin}${path}`;
          } catch (error) {
            console.warn("Invalid candidate base URL", candidate, error);
          }
        }
        return fallback;
      }

      /**
       * Mirrors the frontend helper by checking query parameters first, then injected globals.
       * Falls back to the local FastAPI endpoint when nothing explicit is supplied.
       */
      function inferApiBaseUrl() {
        const searchParams = new URLSearchParams(window.location.search);
        const explicitParam =
          searchParams.get("apiBaseUrl") ?? searchParams.get("api_base_url") ?? undefined;

        if (explicitParam) {
          return resolveApiBaseUrl(explicitParam, DEFAULT_API_BASE_URL);
        }

        const injected =
          window.__API_BASE_URL__ ??
          window.__NEXT_PUBLIC_API_BASE_URL__ ??
          window.NEXT_PUBLIC_API_BASE_URL ??
          document.body?.dataset?.apiBaseUrl ??
          document.querySelector("meta[name='api-base-url']")?.getAttribute("content") ??
          undefined;

        return resolveApiBaseUrl(injected, DEFAULT_API_BASE_URL);
      }

      /**
       * Maps division labels to palette colors with stable hashing.
       * @param {string | null | undefined} division
       */
      function getDivisionColor(division) {
        if (!division) {
          return DEFAULT_DIVISION_COLOR;
        }
        if (!getDivisionColor.cache) {
          getDivisionColor.cache = new Map();
        }
        if (!getDivisionColor.cache.has(division)) {
          const nextIndex = getDivisionColor.cache.size % COLOR_PALETTE.length;
          getDivisionColor.cache.set(division, COLOR_PALETTE[nextIndex]);
        }
        return getDivisionColor.cache.get(division);
      }
      getDivisionColor.cache = /** @type {Map<string, string>} */ (new Map());

      /**
       * Fetches the fight graph payload and validates the shape loosely.
       * @returns {Promise<FightGraphResponse>}
       */
      async function loadFightGraph() {
        const baseUrl = inferApiBaseUrl();
        const url = `${baseUrl.replace(/\/$/, "")}/fightweb/graph`;
        updateStatus("loading", `Fetching graph data from ${url}`);
        const response = await fetch(url, {
          headers: {
            Accept: "application/json",
          },
        });
        if (!response.ok) {
          const text = await response.text();
          throw new Error(`API responded with ${response.status}: ${text || response.statusText}`);
        }
        /** @type {unknown} */
        const payload = await response.json();
        if (!payload || typeof payload !== "object") {
          throw new Error("Fight graph payload was empty or malformed.");
        }
        return /** @type {FightGraphResponse} */ (payload);
      }

      /**
       * Executes a force-directed layout in 3D space before rendering the meshes.
       * @param {FightGraphNode[]} nodes
       * @param {FightGraphLink[]} links
       * @param {number} iterations
       */
      async function computeLayout(nodes, links, iterations) {
        const nodeMap = new Map(nodes.map((node) => [node.fighter_id, node]));
        const simNodes = nodes.map((node) => ({ ...node }));
        const simLinks = links
          .filter((link) => nodeMap.has(link.source) && nodeMap.has(link.target))
          .map((link) => ({ ...link }));

        return new Promise((resolve) => {
          const simulation = forceSimulation(simNodes)
            .force(
              "charge",
              forceManyBody().strength(-180)
            )
            .force(
              "link",
              forceLink(simLinks)
                .id((node) => node.fighter_id)
                .distance((link) => 140 - Math.min(80, link.fights * 10))
                .strength(0.18)
            )
            .force("center", forceCenter(0, 0, 0))
            .stop();

          const steps = Math.max(10, iterations);
          for (let i = 0; i < steps; i += 1) {
            simulation.tick();
          }

          resolve({ nodes: simNodes, links: simLinks });
        });
      }

      /**
       * Builds Three.js meshes representing fighters (spheres) and bouts (cylinders).
       * @param {THREE.Scene} scene
       * @param {{ nodes: (FightGraphNode & { x: number; y: number; z: number })[]; links: FightGraphLink[] }} layout
       */
      function populateScene(scene, layout) {
        const nodeGeometryCache = new Map();
        const divisionMaterialCache = new Map();

        const nodeGroup = new THREE.Group();
        nodeGroup.name = "fighters";
        scene.add(nodeGroup);

        const edgeGroup = new THREE.Group();
        edgeGroup.name = "bouts";
        scene.add(edgeGroup);

        const sphereBaseRadius = 2.4;

        layout.nodes.forEach((node) => {
          const radius = sphereBaseRadius + Math.sqrt(Math.max(1, node.total_fights));
          if (!nodeGeometryCache.has(radius)) {
            nodeGeometryCache.set(radius, new THREE.SphereGeometry(radius, 32, 32));
          }
          const color = getDivisionColor(node.division);
          if (!divisionMaterialCache.has(color)) {
            divisionMaterialCache.set(
              color,
              new THREE.MeshStandardMaterial({ color, roughness: 0.35, metalness: 0.45 })
            );
          }
          const sphere = new THREE.Mesh(
            nodeGeometryCache.get(radius),
            divisionMaterialCache.get(color)
          );
          sphere.position.set(node.x ?? 0, node.y ?? 0, node.z ?? 0);
          sphere.userData = node;
          nodeGroup.add(sphere);
        });

        const edgeMaterialCache = new Map();

        layout.links.forEach((link) => {
          const source = layout.nodes.find((node) => node.fighter_id === link.source);
          const target = layout.nodes.find((node) => node.fighter_id === link.target);
          if (!source || !target) {
            return;
          }
          const color = getDivisionColor(source.division ?? target.division);
          if (!edgeMaterialCache.has(color)) {
            edgeMaterialCache.set(
              color,
              new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.45 })
            );
          }
          const start = new THREE.Vector3(source.x ?? 0, source.y ?? 0, source.z ?? 0);
          const end = new THREE.Vector3(target.x ?? 0, target.y ?? 0, target.z ?? 0);
          const distance = start.distanceTo(end);
          if (!Number.isFinite(distance) || distance === 0) {
            return;
          }
          const cylinderGeometry = new THREE.CylinderGeometry(0.6, 0.6, distance, 8, 1, true);
          const edge = new THREE.Mesh(cylinderGeometry, edgeMaterialCache.get(color));
          const midpoint = start.clone().lerp(end, 0.5);
          edge.position.copy(midpoint);
          edge.lookAt(end);
          edge.rotateX(Math.PI / 2);
          edge.userData = link;
          edgeGroup.add(edge);
        });

        return { nodeGroup, edgeGroup };
      }

      /**
       * Creates the renderer, camera, lights, and orbit controls for the scene.
       */
      function initializeRenderer() {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color("#020617");

        const camera = new THREE.PerspectiveCamera(
          60,
          sceneContainer.clientWidth / sceneContainer.clientHeight,
          0.1,
          5000
        );
        camera.position.set(0, 220, 520);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
        renderer.shadowMap.enabled = true;
        sceneContainer.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight("#cbd5f5", 0.45);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight("#ffffff", 0.9);
        keyLight.position.set(280, 420, 200);
        keyLight.castShadow = true;
        scene.add(keyLight);

        const rimLight = new THREE.PointLight("#38bdf8", 0.6, 1200, 2);
        rimLight.position.set(-320, -180, -260);
        scene.add(rimLight);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 60;
        controls.maxDistance = 1200;

        return { scene, camera, renderer, controls };
      }

      /**
       * Sets up hover + selection handling using a raycaster and HTML tooltip overlay.
       * @param {THREE.PerspectiveCamera} camera
       * @param {THREE.WebGLRenderer} renderer
       * @param {THREE.Group} nodeGroup
       */
      function registerInteractions(camera, renderer, nodeGroup) {
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let lockedTarget = null;

        function updateTooltip(intersection) {
          if (!intersection) {
            tooltip.style.display = lockedTarget ? "block" : "none";
            if (!lockedTarget) {
              tooltip.textContent = "";
            }
            return;
          }
          const node = intersection.object.userData;
          tooltip.innerHTML = `
            <strong>${node.name}</strong><br />
            <span>Total fights: ${node.total_fights}</span><br />
            <span>Division: ${node.division ?? "Unknown"}</span><br />
            <span>Record: ${node.record ?? "Unavailable"}</span><br />
            <span>Latest event: ${node.latest_event_date ?? "Unknown"}</span>
          `;
          tooltip.style.display = "block";
        }

        function projectTooltip(intersection) {
          if (!intersection) {
            return;
          }
          const vector = intersection.object.position.clone();
          vector.project(camera);
          const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
          const y = (-vector.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
          tooltip.style.left = `${x}px`;
          tooltip.style.top = `${y}px`;
        }

        function handlePointerMove(event) {
          const bounds = renderer.domElement.getBoundingClientRect();
          pointer.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
          pointer.y = -(((event.clientY - bounds.top) / bounds.height) * 2 - 1);
          raycaster.setFromCamera(pointer, camera);
          const intersections = raycaster.intersectObjects(nodeGroup.children, false);
          const intersection = intersections[0];
          if (!lockedTarget) {
            updateTooltip(intersection);
            if (intersection) {
              projectTooltip(intersection);
            }
          } else {
            projectTooltip({ object: lockedTarget });
          }
        }

        function handleClick(event) {
          const bounds = renderer.domElement.getBoundingClientRect();
          pointer.x = ((event.clientX - bounds.left) / bounds.width) * 2 - 1;
          pointer.y = -(((event.clientY - bounds.top) / bounds.height) * 2 - 1);
          raycaster.setFromCamera(pointer, camera);
          const intersections = raycaster.intersectObjects(nodeGroup.children, false);
          const intersection = intersections[0];
          if (intersection) {
            lockedTarget = intersection.object;
            updateTooltip(intersection);
            projectTooltip(intersection);
          } else {
            lockedTarget = null;
            tooltip.style.display = "none";
          }
        }

        renderer.domElement.addEventListener("pointermove", handlePointerMove);
        renderer.domElement.addEventListener("click", handleClick);

        window.addEventListener("resize", () => {
          camera.aspect = sceneContainer.clientWidth / sceneContainer.clientHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(sceneContainer.clientWidth, sceneContainer.clientHeight);
        });
      }

      (async function bootstrap() {
        try {
          const iterationsParam = Number(
            new URLSearchParams(window.location.search).get("iterations") ?? ""
          );
          const iterations = Number.isFinite(iterationsParam) && iterationsParam > 0
            ? Math.min(iterationsParam, 600)
            : 180;
          updateStatus("loading", "Downloading fight graph…");
          const data = await loadFightGraph();
          updateStatus("loading", `Computing force layout with ${iterations} ticks…`);
          const layout = await computeLayout(data.nodes, data.links, iterations);
          updateStatus("success", `Graph ready — ${layout.nodes.length} fighters, ${layout.links.length} bouts.`);

          const { scene, camera, renderer, controls } = initializeRenderer();
          const { nodeGroup } = populateScene(scene, layout);
          registerInteractions(camera, renderer, nodeGroup);

          function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
          }

          animate();
        } catch (error) {
          console.error(error);
          updateStatus(
            "error",
            `Failed to load fight graph: ${error instanceof Error ? error.message : String(error)}`
          );
          tooltip.style.display = "none";
        }
      })();
    </script>
  </body>
</html>
